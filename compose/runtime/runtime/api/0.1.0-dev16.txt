// Signature format: 3.0
package androidx.compose.runtime {

  @androidx.compose.runtime.ExperimentalComposeApi public abstract class AbstractApplier<T> implements androidx.compose.runtime.Applier<T> {
    ctor public AbstractApplier(T! root);
    method public final void clear();
    method public void down(T? node);
    method public T! getCurrent();
    method public final T! getRoot();
    method protected final void move(java.util.List<T>, int from, int to, int count);
    method protected abstract void onClear();
    method protected final void remove(java.util.List<T>, int index, int count);
    method protected void setCurrent(T! p);
    method public void up();
    property public T! current;
  }

  public final class ActualAndroidKt {
    method public static androidx.compose.runtime.EmbeddingContext EmbeddingContext();
  }

  public final class ActualJvmKt {
  }

  @androidx.compose.runtime.Stable public abstract sealed class Ambient<T> {
    method public final inline T! getCurrent();
    property public final inline T! current;
  }

  public final class AmbientKt {
    method @androidx.compose.runtime.Composable public static void Providers(androidx.compose.runtime.ProvidedValue<?>![] values, kotlin.jvm.functions.Function0<kotlin.Unit> children);
    method public static <T> androidx.compose.runtime.ProvidableAmbient<T> ambientOf(androidx.compose.runtime.SnapshotMutationPolicy<T> policy = referentialEqualityPolicy(), kotlin.jvm.functions.Function0<? extends T>? defaultFactory = null);
    method public static <T> androidx.compose.runtime.ProvidableAmbient<T> staticAmbientOf(kotlin.jvm.functions.Function0<? extends T>? defaultFactory = null);
  }

  @androidx.compose.runtime.InternalComposeApi public final class Anchor {
    ctor public Anchor(internal int loc);
    method public boolean getValid();
    method public int location(androidx.compose.runtime.SlotTable slots);
    property public final boolean valid;
  }

  public final class AndroidEmbeddingContext implements androidx.compose.runtime.EmbeddingContext {
    ctor public AndroidEmbeddingContext();
    method public void cancelFrameCallback(android.view.Choreographer.FrameCallback callback);
    method public boolean isMainThread();
    method public kotlin.coroutines.CoroutineContext mainThreadCompositionContext();
    method public void postFrameCallback(android.view.Choreographer.FrameCallback callback);
    method public void postOnMainThread(kotlin.jvm.functions.Function0<kotlin.Unit> block);
  }

  @androidx.compose.runtime.ExperimentalComposeApi public interface Applier<N> {
    method public void clear();
    method public void down(N? node);
    method public N! getCurrent();
    method public void insert(int index, N? instance);
    method public void move(int from, int to, int count);
    method public void remove(int index, int count);
    method public void up();
    property public abstract N! current;
  }

  public final class BitwiseOperatorsKt {
  }

  public final class BuildableMap<K, V> implements kotlin.jvm.internal.markers.KMappedMarker java.util.Map<K,V> {
    ctor public BuildableMap(kotlinx.collections.immutable.PersistentMap<K,? extends V> map);
    method public kotlinx.collections.immutable.PersistentMap<K,V> component1();
    method public boolean containsKey(Object! key);
    method public boolean containsValue(Object! value);
    method public androidx.compose.runtime.BuildableMap<K,V> copy(kotlinx.collections.immutable.PersistentMap<K,? extends V> map);
    method public V? get(Object! key);
    method public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method public java.util.Set<K> getKeys();
    method public kotlinx.collections.immutable.PersistentMap<K,V> getMap();
    method public int getSize();
    method public java.util.Collection<V> getValues();
    method public boolean isEmpty();
  }

  public interface CommitScope {
    method public void onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> callback);
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.FUNCTION, AnnotationTarget.TYPE, AnnotationTarget.TYPE_PARAMETER, AnnotationTarget.PROPERTY}) public @interface Composable {
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.TYPE}) public @interface ComposableContract {
    method public abstract boolean preventCapture() default false;
    method public abstract boolean readonly() default false;
    method public abstract boolean restartable() default true;
    method public abstract boolean tracked() default true;
  }

  @kotlin.RequiresOptIn(level=RequiresOptIn.Level.WARNING, message="This API is intended to be targeted by the Compose Compiler Plugin and not called " + "directly.") @kotlin.annotation.Target(allowedTargets={AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.TYPEALIAS}) public @interface ComposeCompilerApi {
  }

  public final class ComposeKt {
    method @androidx.compose.runtime.Stable public static kotlin.jvm.functions.Function0<kotlin.Unit> emptyContent();
    method public static inline kotlin.jvm.functions.Function0<kotlin.Unit> orEmpty(kotlin.jvm.functions.Function0<kotlin.Unit>?);
  }

  public final class Composer<N> {
    ctor public Composer(androidx.compose.runtime.SlotTable slotTable, androidx.compose.runtime.Applier<N> applier, androidx.compose.runtime.Recomposer recomposer);
    method @androidx.compose.runtime.InternalComposeApi public void applyChanges();
    method @androidx.compose.runtime.ComposeCompilerApi public inline <T> T! cache(boolean invalid, kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(Object? value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(char value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(byte value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(short value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(boolean value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(float value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(long value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(double value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(int value);
    method @androidx.compose.runtime.InternalComposeApi public void collectKeySourceInformation();
    method @androidx.compose.runtime.InternalComposeApi public void composeRoot(kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method @androidx.compose.runtime.ComposeCompilerApi public <T extends N> void createNode(kotlin.jvm.functions.Function0<? extends T> factory);
    method @androidx.compose.runtime.ComposeCompilerApi public void emitNode(Object? node);
    method @androidx.compose.runtime.ComposeCompilerApi public void endDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void endMovableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endNode();
    method @androidx.compose.runtime.ComposeCompilerApi public void endReplaceableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public androidx.compose.runtime.ScopeUpdateScope? endRestartGroup();
    method public androidx.compose.runtime.Applier<N> getApplier();
    method public int getCurrentCompoundKeyHash();
    method public boolean getDefaultsInvalid();
    method public boolean getInserting();
    method public androidx.compose.runtime.Recomposer getRecomposer();
    method public boolean getSkipping();
    method public androidx.compose.runtime.SlotTable getSlotTable();
    method @androidx.compose.runtime.ComposeCompilerApi public Object joinKey(Object? left, Object? right);
    method @androidx.compose.runtime.ComposeCompilerApi public Object? nextSlot();
    method @androidx.compose.runtime.InternalComposeApi public boolean recompose();
    method @androidx.compose.runtime.ComposeCompilerApi public void skipCurrentGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void skipToGroupEnd();
    method @androidx.compose.runtime.ComposeCompilerApi public void startDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void startMovableGroup(int key, Object? dataKey);
    method @androidx.compose.runtime.ComposeCompilerApi public void startMovableGroup(int key, Object? dataKey, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public void startNode();
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceableGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceableGroup(int key, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public void startRestartGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startRestartGroup(int key, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public N! useNode();
    property public final int currentCompoundKeyHash;
    property public final boolean defaultsInvalid;
    property public final boolean inserting;
    property public final boolean skipping;
  }

  public final class ComposerKt {
    method public static androidx.compose.runtime.Composer<?> getCurrentComposer();
  }

  public interface Composition {
    method public void dispose();
    method public void setContent(kotlin.jvm.functions.Function0<kotlin.Unit> content);
  }

  public abstract class CompositionCoroutineScope implements kotlinx.coroutines.CoroutineScope androidx.compose.runtime.dispatch.MonotonicFrameClock {
    ctor public CompositionCoroutineScope();
    method @Deprecated public final suspend Object? awaitFrame(kotlin.coroutines.Continuation<? super java.lang.Long> p);
  }

  @Deprecated public interface CompositionFrameClock extends androidx.compose.runtime.dispatch.MonotonicFrameClock {
    method @Deprecated public default suspend <R> Object? awaitFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
  }

  public final class CompositionFrameClockKt {
    method @Deprecated public static suspend inline <R> Object? awaitFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
    method @Deprecated public static suspend Object? awaitFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.coroutines.Continuation<? super java.lang.Long> p);
    method @Deprecated public static suspend Object? awaitFrameNanos(androidx.compose.runtime.CompositionFrameClock, kotlin.coroutines.Continuation<? super java.lang.Long> p);
    method @Deprecated public static suspend inline <R> Object? withFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
  }

  public final class CompositionKt {
    method @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.Composition compositionFor(Object key, androidx.compose.runtime.Applier<?> applier, androidx.compose.runtime.Recomposer recomposer, androidx.compose.runtime.CompositionReference? parent = null, kotlin.jvm.functions.Function0<kotlin.Unit> onCreated = {});
  }

  public interface CompositionLifecycleObserver {
    method public default void onEnter();
    method public default void onLeave();
  }

  public abstract class CompositionReference {
  }

  public final class EffectsKt {
    method @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionReference compositionReference();
    method public static kotlin.jvm.functions.Function0<kotlin.Unit> getInvalidate();
    method @androidx.compose.runtime.Composable public static void onActive(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static inline void onCommit(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1> void onCommit(V1? v1, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1, V2> void onCommit(V1? v1, V2? v2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static void onCommit(Object![]? inputs, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static void onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static inline void onPreCommit(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1> void onPreCommit(V1? v1, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1, V2> void onPreCommit(V1? v1, V2? v2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static void onPreCommit(Object![]? inputs, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
  }

  public interface EmbeddingContext {
    method public void cancelFrameCallback(android.view.Choreographer.FrameCallback callback);
    method public boolean isMainThread();
    method public kotlin.coroutines.CoroutineContext mainThreadCompositionContext();
    method public void postFrameCallback(android.view.Choreographer.FrameCallback callback);
    method public void postOnMainThread(kotlin.jvm.functions.Function0<kotlin.Unit> block);
  }

  public final class EmitKt {
    method @androidx.compose.runtime.Composable public static inline <T extends java.lang.Object, reified E extends androidx.compose.runtime.Applier<?>> void emit(kotlin.jvm.functions.Function0<? extends T> ctor, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,? extends kotlin.Unit> update);
    method @androidx.compose.runtime.Composable public static inline <T extends java.lang.Object, reified E extends androidx.compose.runtime.Applier<?>> void emit(kotlin.jvm.functions.Function0<? extends T> ctor, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,? extends kotlin.Unit> update, kotlin.jvm.functions.Function0<? extends kotlin.Unit> children);
  }

  public final class ExpectKt {
  }

  @kotlin.RequiresOptIn(level=RequiresOptIn.Level.ERROR, message="This is an experimental API for Compose and is likely to change before becoming " + "stable.") @kotlin.annotation.Target(allowedTargets={AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY}) public @interface ExperimentalComposeApi {
  }

  public final class FlowAdapterKt {
    method @androidx.compose.runtime.Composable @kotlinx.coroutines.ExperimentalCoroutinesApi public static inline <T> androidx.compose.runtime.State<T> collectAsState(kotlinx.coroutines.flow.StateFlow<? extends T>, kotlin.coroutines.CoroutineContext context = Dispatchers.Main);
    method @androidx.compose.runtime.Composable public static <T extends R, R> androidx.compose.runtime.State<R> collectAsState(kotlinx.coroutines.flow.Flow<? extends T>, R? initial, kotlin.coroutines.CoroutineContext context = Dispatchers.Main);
  }

  public final class FrameManager {
    method public void ensureStarted();
    method @Deprecated public <T> T! framed(kotlin.jvm.functions.Function0<? extends T> block);
    method @Deprecated @org.jetbrains.annotations.TestOnly public <T> T! isolated(kotlin.jvm.functions.Function0<? extends T> block);
    method @Deprecated public void nextFrame();
    method @Deprecated @org.jetbrains.annotations.TestOnly public <T> T! unframed(kotlin.jvm.functions.Function0<? extends T> block);
    field public static final androidx.compose.runtime.FrameManager INSTANCE;
  }

  @androidx.compose.runtime.StableMarker @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=AnnotationTarget.CLASS) public @interface Immutable {
  }

  @kotlin.RequiresOptIn(level=RequiresOptIn.Level.ERROR, message="This is internal API for Compose modules that may change frequently " + "and without warning.") @kotlin.annotation.Target(allowedTargets={AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY}) public @interface InternalComposeApi {
  }

  public final class JoinedKeyKt {
    method @androidx.compose.runtime.InternalComposeApi public static boolean isJoinedKey(Object? key);
    method @androidx.compose.runtime.InternalComposeApi public static Object? joinedKeyLeft(Object? key);
    method @androidx.compose.runtime.InternalComposeApi public static Object? joinedKeyRight(Object? key);
  }

  @androidx.compose.runtime.InternalComposeApi public final class KeyInfo {
    method public Object? getDataKey();
    method public int getIndex();
    method public int getKey();
    method public int getLocation();
    method public int getNodes();
  }

  public final class KeyKt {
    method @androidx.compose.runtime.Composable public static inline <T> T! key(Object![]? inputs, kotlin.jvm.functions.Function0<? extends T> block);
  }

  public final class KeySourceInfoKt {
    method @androidx.compose.runtime.InternalComposeApi public static String? keySourceInfoOf(Object key);
    method @androidx.compose.runtime.InternalComposeApi public static void resetSourceInfo();
  }

  @androidx.compose.runtime.Stable public interface MutableState<T> extends androidx.compose.runtime.State<T> {
    method public operator T! component1();
    method public operator kotlin.jvm.functions.Function1<T,kotlin.Unit> component2();
    method public void setValue(T! p);
    property public abstract T! value;
  }

  public final class MutableStateKt {
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getNeverEqual();
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getReferentiallyEqual();
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getStructurallyEqual();
    method public static inline operator <T> T! getValue(androidx.compose.runtime.State<T>, Object? thisObj, kotlin.reflect.KProperty<?> property);
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf();
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf(T?... elements);
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf();
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf(kotlin.Pair<? extends K,? extends V>... pairs);
    method public static <T> androidx.compose.runtime.MutableState<T> mutableStateOf(T? value, androidx.compose.runtime.SnapshotMutationPolicy<T> policy = referentialEqualityPolicy());
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> neverEqualPolicy();
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> referentialEqualityPolicy();
    method public static inline operator <T> void setValue(androidx.compose.runtime.MutableState<T>, Object? thisObj, kotlin.reflect.KProperty<?> property, T? value);
    method @androidx.compose.runtime.Composable public static inline <T> androidx.compose.runtime.MutableState<T> state(androidx.compose.runtime.SnapshotMutationPolicy<T> policy = referentialEqualityPolicy(), kotlin.jvm.functions.Function0<? extends T> init);
    method @androidx.compose.runtime.Composable public static inline <T, V1> androidx.compose.runtime.MutableState<T> stateFor(V1? v1, kotlin.jvm.functions.Function0<? extends T> init);
    method @androidx.compose.runtime.Composable public static inline <T> androidx.compose.runtime.MutableState<T> stateFor(Object![]? inputs, kotlin.jvm.functions.Function0<? extends T> init);
    method @androidx.compose.runtime.Composable public static inline <T, reified V1, reified V2> androidx.compose.runtime.MutableState<T>! stateFor(V1? v1, V2? v2, kotlin.jvm.functions.Function0<? extends T> init);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> structuralEqualityPolicy();
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> toMutableStateList(java.util.Collection<? extends T>);
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> toMutableStateMap(Iterable<? extends kotlin.Pair<? extends K,? extends V>>);
  }

  @kotlin.annotation.Retention(AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION, AnnotationTarget.CLASS, AnnotationTarget.FILE}) public @interface NoLiveLiterals {
  }

  public final class ObserverMap<K, V> {
    ctor public ObserverMap();
    method public void add(K key, V value);
    method public void clear();
    method public void clearValues(kotlin.jvm.functions.Function1<? super V,java.lang.Boolean> predicate);
    method public boolean contains(K key, V value);
    method public operator java.util.List<V> get(Iterable<? extends K> keys);
    method public java.util.List<V> getValueOf(K key);
    method public void remove(K key);
    method public void remove(K key, V value);
    method public void removeValue(V value);
  }

  @androidx.compose.runtime.Stable public abstract class ProvidableAmbient<T> extends androidx.compose.runtime.Ambient<T> {
    method public final infix androidx.compose.runtime.ProvidedValue<T> provides(T? value);
  }

  public final class ProvidedValue<T> {
    method public androidx.compose.runtime.Ambient<T> getAmbient();
    method public T! getValue();
  }

  public final class Recomposer {
    ctor public Recomposer(androidx.compose.runtime.EmbeddingContext embeddingContext);
    ctor public Recomposer();
    method public suspend Object? awaitIdle(kotlin.coroutines.Continuation<? super kotlin.Unit> p);
    method public androidx.compose.runtime.EmbeddingContext getEmbeddingContext();
    method public androidx.compose.runtime.dispatch.MonotonicFrameClock getFrameClock();
    method public boolean hasPendingChanges();
    method public suspend Object? recomposeAndApplyChanges(kotlinx.coroutines.CoroutineScope applyCoroutineScope, long frameCount, kotlin.coroutines.Continuation<? super kotlin.Unit> p);
    method public suspend Object? runRecomposeAndApplyChanges(kotlin.coroutines.Continuation<?> p);
    method public void setEmbeddingContext(androidx.compose.runtime.EmbeddingContext p);
    property public final androidx.compose.runtime.dispatch.MonotonicFrameClock frameClock;
    field public static final androidx.compose.runtime.Recomposer.Companion Companion;
  }

  public static final class Recomposer.Companion {
    method @org.jetbrains.annotations.TestOnly public androidx.compose.runtime.Recomposer current();
  }

  public final class RecomposerKt {
    method public static suspend Object? withRunningRecomposer(kotlin.jvm.functions.Function3<? super kotlinx.coroutines.CoroutineScope,? super androidx.compose.runtime.Recomposer,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block, kotlin.coroutines.Continuation<? super kotlin.Unit> p);
  }

  public final class RememberKt {
    method @androidx.compose.runtime.Composable public static inline <T> T! remember(kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1> T! remember(V1? v1, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1, V2> T! remember(V1? v1, V2? v2, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1, V2, V3> T! remember(V1? v1, V2? v2, V3? v3, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <V> V! remember(Object![]? inputs, kotlin.jvm.functions.Function0<? extends V> calculation);
  }

  @androidx.compose.runtime.ComposeCompilerApi public interface ScopeUpdateScope {
    method public void updateScope(kotlin.jvm.functions.Function3<? super androidx.compose.runtime.Composer<?>,? super java.lang.Integer,? super java.lang.Integer,kotlin.Unit> block);
  }

  @androidx.compose.runtime.InternalComposeApi public final class SlotReader {
    ctor public SlotReader(androidx.compose.runtime.SlotTable table);
    method public void beginEmpty();
    method public void close();
    method public void endEmpty();
    method public void endGroup();
    method public void endNode();
    method public java.util.List<androidx.compose.runtime.KeyInfo> extractKeys();
    method public Object? get(androidx.compose.runtime.Anchor anchor);
    method public Object? get(int index);
    method public int getCurrent();
    method public int getCurrentEnd();
    method public Object! getGroupData();
    method public Object! getGroupDataKey();
    method public int getGroupEnd();
    method public int getGroupKey();
    method public Object! getGroupNode();
    method public int getGroupSize();
    method public boolean getInEmpty();
    method public int getNodeIndex();
    method public int getParentLocation();
    method public int getParentNodes();
    method public int getParentSlots();
    method public androidx.compose.runtime.SlotTable getTable();
    method public int groupEnd(int index);
    method public int groupKey(int index);
    method public int groupSize(int index);
    method public boolean isGroup();
    method public boolean isGroup(int index);
    method public boolean isGroupEnd();
    method public boolean isNode();
    method public boolean isNode(int location);
    method public Object? next();
    method public void reposition(int value);
    method public int skipGroup();
    method public int skipNode();
    method public void skipToGroupEnd();
    method public void startDataGroup();
    method public void startGroup();
    method public void startNode();
    property public final int current;
    property public final int currentEnd;
    property public final Object! groupData;
    property public final Object! groupDataKey;
    property public final int groupEnd;
    property public final int groupKey;
    property public final Object! groupNode;
    property public final int groupSize;
    property public final boolean inEmpty;
    property public final boolean isGroup;
    property public final boolean isGroupEnd;
    property public final boolean isNode;
    property public final int nodeIndex;
    property public final int parentLocation;
    property public final int parentNodes;
    property public final int parentSlots;
  }

  public final class SlotTable {
    ctor public SlotTable(internal Object![] slots);
    ctor public SlotTable();
    method public int getSize();
    method @androidx.compose.runtime.InternalComposeApi public java.util.List<java.lang.Integer> groupPathTo(int location);
    method @androidx.compose.runtime.InternalComposeApi public androidx.compose.runtime.SlotReader openReader();
    method @androidx.compose.runtime.InternalComposeApi public androidx.compose.runtime.SlotWriter openWriter();
    method @androidx.compose.runtime.InternalComposeApi public inline <T> T! read(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.SlotReader,? extends T> block);
    method @androidx.compose.runtime.InternalComposeApi @org.jetbrains.annotations.TestOnly public void verifyWellFormed();
    method @androidx.compose.runtime.InternalComposeApi public inline <T> T! write(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.SlotWriter,? extends T> block);
    property public final int size;
    field public static final androidx.compose.runtime.SlotTable.Companion Companion;
  }

  @androidx.compose.runtime.InternalComposeApi public static final class SlotTable.Companion {
    method public Object getEMPTY();
    property public final Object EMPTY;
  }

  public final class SlotTableKt {
  }

  @androidx.compose.runtime.InternalComposeApi public final class SlotWriter {
    method public androidx.compose.runtime.Anchor anchor(int index = current);
    method public void beginInsert();
    method public void close();
    method public int endData();
    method public int endGroup();
    method public void endInsert();
    method public int endNode();
    method public void ensureStarted(int location);
    method public void ensureStarted(androidx.compose.runtime.Anchor anchor);
    method public Object? get(androidx.compose.runtime.Anchor anchor);
    method public Object? get(int index);
    method public boolean getClosed();
    method public int getCurrent();
    method public int getGroupSize();
    method public int getNodeIndex();
    method public int getParentLocation();
    method public int getParentNodes();
    method public androidx.compose.runtime.SlotTable getTable();
    method public int groupSize(int index);
    method public java.util.Iterator<java.lang.Object> groupSlots();
    method public boolean isGroup();
    method public boolean isGroup(int index);
    method public boolean isNode();
    method public java.util.List<androidx.compose.runtime.Anchor> moveFrom(androidx.compose.runtime.SlotTable table, int location);
    method public void moveGroup(int offset);
    method public int parentIndex(androidx.compose.runtime.Anchor anchor);
    method public boolean removeGroup();
    method public void set(Object? value);
    method public void setCurrent(int p);
    method public Object? skip();
    method public void skip(int amount);
    method public int skipGroup();
    method public int skipNode();
    method public void skipToGroupEnd();
    method public void startData(int key, Object? dataKey, Object? data);
    method public void startGroup();
    method public void startGroup(int key);
    method public void startGroup(int key, Object? dataKey);
    method public void startGroup(int key, Object? dataKey, Object? data);
    method public void startNode();
    method public void startNode(Object? key);
    method public void startNode(Object? key, Object? node);
    method public Object? update(Object? value);
    method public void updateData(Object? value);
    property public final boolean closed;
    property public final int current;
    property public final int groupSize;
    property public final boolean isGroup;
    property public final boolean isNode;
    property public final int nodeIndex;
    property public final int parentLocation;
    property public final int parentNodes;
  }

  public interface SnapshotMutationPolicy<T> {
    method public boolean equivalent(T? a, T? b);
    method @androidx.compose.runtime.ExperimentalComposeApi public default T? merge(T? previous, T? current, T? applied);
  }

  @androidx.compose.runtime.StableMarker @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY}) public @interface Stable {
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS}) public @interface StableMarker {
  }

  @androidx.compose.runtime.Stable public interface State<T> {
    method public T! getValue();
    property public abstract T! value;
  }

  public final class SuspendingEffectsKt {
    method public static suspend Object? awaitDispose(androidx.compose.runtime.CompositionCoroutineScope, kotlin.jvm.functions.Function0<kotlin.Unit> onDispose = {}, kotlin.coroutines.Continuation<?> p = {});
    method @androidx.compose.runtime.Composable public static void launchInComposition(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.CompositionCoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void launchInComposition(Object? key, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.CompositionCoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void launchInComposition(Object? key1, Object? key2, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.CompositionCoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void launchInComposition(Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.CompositionCoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void launchInComposition(Object![]? keys, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.CompositionCoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static inline kotlinx.coroutines.CoroutineScope rememberCoroutineScope(kotlin.jvm.functions.Function0<? extends kotlin.coroutines.CoroutineContext> getContext = { return EmptyCoroutineContext });
  }

  public final class TraceKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={AnnotationTarget.TYPE, AnnotationTarget.TYPE_PARAMETER}) public @interface UnionType {
    method public abstract Class<?>[] types();
  }

  public final class Updater<T> {
    ctor public Updater(androidx.compose.runtime.Composer<?> composer, T! node);
    method public androidx.compose.runtime.Composer<?> getComposer();
    method public T! getNode();
    method public inline void reconcile(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void set(int value, kotlin.jvm.functions.Function2<? super T,? super java.lang.Integer,kotlin.Unit> block);
    method public inline <reified V> void set(V? value, kotlin.jvm.functions.Function2<? super T,? super V,? extends kotlin.Unit> block);
    method public inline void update(int value, kotlin.jvm.functions.Function2<? super T,? super java.lang.Integer,kotlin.Unit> block);
    method public inline <reified V> void update(V? value, kotlin.jvm.functions.Function2<? super T,? super V,? extends kotlin.Unit> block);
  }

}

package androidx.compose.runtime.collection {

  @kotlin.RequiresOptIn(level=RequiresOptIn.Level.ERROR, message="This is an experimental API for fast access collections and is likely to change " + "before becoming stable.") @kotlin.annotation.Target(allowedTargets={AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY}) public @interface ExperimentalCollectionApi {
  }

  @androidx.compose.runtime.collection.ExperimentalCollectionApi public final class MutableVector<T> {
    method public boolean add(T? element);
    method public void add(int index, T? element);
    method public boolean addAll(int index, java.util.List<? extends T> elements);
    method public boolean addAll(int index, androidx.compose.runtime.collection.MutableVector<T> elements);
    method public inline boolean addAll(java.util.List<? extends T> elements);
    method public inline boolean addAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean addAll(T![] elements);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public inline boolean any(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public java.util.List<T> asMutableList();
    method public void clear();
    method public operator boolean contains(T? element);
    method public boolean containsAll(java.util.List<? extends T> elements);
    method public boolean containsAll(java.util.Collection<? extends T> elements);
    method public boolean containsAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean contentEquals(androidx.compose.runtime.collection.MutableVector<T> other);
    method public void ensureCapacity(int capacity);
    method public T! first();
    method public inline T! first(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline T? firstOrNull();
    method public inline T? firstOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline <R> R! fold(R? initial, kotlin.jvm.functions.Function2<? super R,? super T,? extends R> operation);
    method public inline <R> R! foldIndexed(R? initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super R,? super T,? extends R> operation);
    method public inline <R> R! foldRight(R? initial, kotlin.jvm.functions.Function2<? super T,? super R,? extends R> operation);
    method public inline <R> R! foldRightIndexed(R? initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super T,? super R,? extends R> operation);
    method public inline void forEach(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline void forEachReversed(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachReversedIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline operator T! get(int index);
    method public inline kotlin.ranges.IntRange getIndices();
    method public inline int getLastIndex();
    method public int getSize();
    method public int indexOf(T? element);
    method public inline int indexOfFirst(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline int indexOfLast(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public boolean isEmpty();
    method public boolean isNotEmpty();
    method public T! last();
    method public inline T! last(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public int lastIndexOf(T? element);
    method public inline T? lastOrNull();
    method public inline T? lastOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline <reified R> R![]! map(kotlin.jvm.functions.Function1<? super T,? extends R> transform);
    method public inline <reified R> R![]! mapIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,? extends R> transform);
    method public inline <reified R> androidx.compose.runtime.collection.MutableVector<R>! mapIndexedNotNull(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,? extends R> transform);
    method public inline <reified R> androidx.compose.runtime.collection.MutableVector<R>! mapNotNull(kotlin.jvm.functions.Function1<? super T,? extends R> transform);
    method public inline operator void plusAssign(T? element);
    method public boolean remove(T? element);
    method public boolean removeAll(java.util.List<? extends T> elements);
    method public boolean removeAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean removeAll(java.util.Collection<? extends T> elements);
    method public T! removeAt(int index);
    method public void removeRange(int start, int end);
    method public boolean retainAll(java.util.Collection<? extends T> elements);
    method public operator T! set(int index, T? element);
    method public void sortWith(java.util.Comparator<T> comparator);
    method public inline int sumBy(kotlin.jvm.functions.Function1<? super T,java.lang.Integer> selector);
    property public final inline kotlin.ranges.IntRange indices;
    property public final inline int lastIndex;
    property public final int size;
  }

  public final class MutableVectorKt {
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! MutableVector(int capacity = 16);
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! MutableVector(int size, kotlin.jvm.functions.Function1<? super java.lang.Integer,? extends T> init);
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! mutableVectorOf();
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! mutableVectorOf(T? elements);
  }

}

package androidx.compose.runtime.frames {

  @Deprecated public abstract class AbstractRecord implements androidx.compose.runtime.frames.Record {
    ctor @Deprecated public AbstractRecord();
    method @Deprecated public int getFrameId();
    method @Deprecated public androidx.compose.runtime.frames.Record? getNext();
    method @Deprecated public void setFrameId(int p);
    method @Deprecated public void setNext(androidx.compose.runtime.frames.Record? p);
    property public int frameId;
    property public androidx.compose.runtime.frames.Record? next;
  }

  public final class Frame {
    method public int getId();
    method public boolean getReadonly();
    method public boolean hasPendingChanges();
    property public final boolean readonly;
  }

  @Deprecated public final class FrameAborted extends java.lang.RuntimeException {
    ctor @Deprecated public FrameAborted(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public androidx.compose.runtime.frames.Frame getFrame();
  }

  public final class FrameContainersKt {
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf();
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf(T? element);
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf(T?... elements);
    method @Deprecated public static <K, V> androidx.compose.runtime.frames.ModelMap<K,V> modelMapOf();
    method @Deprecated public static <K, V> androidx.compose.runtime.frames.ModelMap<K,V> modelMapOf(kotlin.Pair<? extends K,? extends V>... pairs);
  }

  public final class FrameIdSetKt {
  }

  @Deprecated public interface Framed {
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    property public abstract androidx.compose.runtime.frames.Record firstFrameRecord;
  }

  public final class FramesKt {
    method @Deprecated public static void _created(androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static androidx.compose.runtime.frames.Record _readable(androidx.compose.runtime.frames.Record r, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static androidx.compose.runtime.frames.Record _writable(androidx.compose.runtime.frames.Record r, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static void abort();
    method @Deprecated public static void abort(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void abortHandler();
    method @Deprecated public static void abortHandler(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void commit();
    method @Deprecated public static void commit(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void commitHandler();
    method @Deprecated public static androidx.compose.runtime.frames.Frame currentFrame();
    method @Deprecated public static boolean getInFrame();
    method @Deprecated public static void observeAllReads(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit> readObserver, kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method @Deprecated public static void open(boolean readOnly = false);
    method @Deprecated public static void open(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null, kotlin.jvm.functions.Function2<java.lang.Object,? super java.lang.Boolean,kotlin.Unit>? writeObserver = null);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T readable(T, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static kotlin.jvm.functions.Function0<kotlin.Unit> registerCommitObserver(kotlin.jvm.functions.Function2<? super java.util.Set<?>,? super androidx.compose.runtime.frames.Frame,kotlin.Unit> observer);
    method @Deprecated public static void restore(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static androidx.compose.runtime.frames.Frame suspend();
    method @Deprecated public static boolean wasModified(Object value);
    method @Deprecated public static inline <T extends androidx.compose.runtime.frames.Record> T withCurrent(T, kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T writable(T, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T writable(T, androidx.compose.runtime.frames.Framed framed, androidx.compose.runtime.frames.Frame frame);
  }

  @Deprecated public final class ModelList<T> implements androidx.compose.runtime.frames.Framed kotlin.jvm.internal.markers.KMutableList java.util.List<T> {
    ctor @Deprecated public ModelList();
    method @Deprecated public boolean add(T? element);
    method @Deprecated public void add(int index, T? element);
    method @Deprecated public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method @Deprecated public boolean addAll(java.util.Collection<? extends T> elements);
    method @Deprecated public void clear();
    method @Deprecated public boolean contains(Object? element);
    method @Deprecated public boolean containsAll(java.util.Collection<?> elements);
    method @Deprecated public T! get(int index);
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public int getSize();
    method @Deprecated public int indexOf(Object? element);
    method @Deprecated public boolean isEmpty();
    method @Deprecated public java.util.Iterator<T> iterator();
    method @Deprecated public int lastIndexOf(Object? element);
    method @Deprecated public java.util.ListIterator<T> listIterator();
    method @Deprecated public java.util.ListIterator<T> listIterator(int index);
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    method @Deprecated public boolean remove(Object? element);
    method @Deprecated public boolean removeAll(java.util.Collection<?> elements);
    method @Deprecated public T! removeAt(int index);
    method @Deprecated public boolean retainAll(java.util.Collection<?> elements);
    method @Deprecated public T! set(int index, T? element);
    method @Deprecated public java.util.List<T> subList(int fromIndex, int toIndex);
    property public androidx.compose.runtime.frames.Record firstFrameRecord;
    property public int size;
  }

  @Deprecated public final class ModelMap<K, V> implements androidx.compose.runtime.frames.Framed kotlin.jvm.internal.markers.KMutableMap java.util.Map<K,V> {
    ctor @Deprecated public ModelMap();
    method @Deprecated public void clear();
    method @Deprecated public boolean containsKey(Object? key);
    method @Deprecated public boolean containsValue(Object? value);
    method @Deprecated public V? get(Object? key);
    method @Deprecated public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public java.util.Set<K> getKeys();
    method @Deprecated public int getSize();
    method @Deprecated public java.util.Collection<V> getValues();
    method @Deprecated public boolean isEmpty();
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    method @Deprecated public V? put(K? key, V? value);
    method @Deprecated public void putAll(java.util.Map<? extends K,? extends V> from);
    method @Deprecated public V? remove(Object? key);
    property public java.util.Set<java.util.Map.Entry<K,V>> entries;
    property public androidx.compose.runtime.frames.Record firstFrameRecord;
    property public java.util.Set<K> keys;
    property public int size;
    property public java.util.Collection<V> values;
  }

  @Deprecated public interface Record {
    method @Deprecated public void assign(androidx.compose.runtime.frames.Record value);
    method @Deprecated public androidx.compose.runtime.frames.Record create();
    method @Deprecated public int getFrameId();
    method @Deprecated public androidx.compose.runtime.frames.Record? getNext();
    method @Deprecated public void setFrameId(int p);
    method @Deprecated public void setNext(androidx.compose.runtime.frames.Record? p);
    property public abstract int frameId;
    property public abstract androidx.compose.runtime.frames.Record? next;
  }

}

package androidx.compose.runtime.internal {

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public final class ComposableLambda<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, R> implements kotlin.jvm.functions.Function10<P1,P2,P3,P4,P5,P6,P7,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function11<P1,P2,P3,P4,P5,P6,P7,P8,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function12<P1,P2,P3,P4,P5,P6,P7,P8,P9,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function13<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function14<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function15<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function16<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function17<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function18<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function20<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function21<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function22<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,P18,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function3<androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function4<P1,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function5<P1,P2,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function6<P1,P2,P3,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function7<P1,P2,P3,P4,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function8<P1,P2,P3,P4,P5,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function9<P1,P2,P3,P4,P5,P6,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> {
    ctor public ComposableLambda(int key, boolean tracked, String? sourceInformation);
    method public int getKey();
    method public operator R! invoke(androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, androidx.compose.runtime.Composer<?> c, int k, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, androidx.compose.runtime.Composer<?> c, int k, int changed, int changed1);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, P17? p17, androidx.compose.runtime.Composer<?> c, int k, int changed, int changed1);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, P17? p17, P18? p18, androidx.compose.runtime.Composer<?> c, int k, int changed, int changed1);
    method public void update(Object block);
  }

  public final class ComposableLambdaKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda<java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object> composableLambda(androidx.compose.runtime.Composer<?> composer, int key, boolean tracked, String? sourceInformation, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda<java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object> composableLambdaInstance(int key, boolean tracked, Object block);
  }

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public final class ComposableLambdaN<R> implements kotlin.jvm.functions.FunctionN<R> {
    ctor public ComposableLambdaN(int key, boolean tracked, String? sourceInformation, int arity);
    method public int getArity();
    method public int getKey();
    method public R! invoke(java.lang.Object?... args);
    method public void update(Object block);
  }

  public final class ComposableLambdaNKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN<?> composableLambdaN(androidx.compose.runtime.Composer<?> composer, int key, boolean tracked, String? sourceInformation, int arity, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN<?> composableLambdaNInstance(int key, boolean tracked, int arity, Object block);
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(AnnotationRetention.BINARY) public @interface LiveLiteralFileInfo {
    method public abstract String file();
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(AnnotationRetention.BINARY) public @interface LiveLiteralInfo {
    method public abstract String key();
    method public abstract int offset();
  }

  public final class LiveLiteralKt {
    method @androidx.compose.runtime.InternalComposeApi public static <T> androidx.compose.runtime.State<T> liveLiteral(String key, T? value);
    method @androidx.compose.runtime.InternalComposeApi public static void updateLiveLiteralValue(String key, Object? value);
  }

}

package androidx.compose.runtime.snapshots {

  public final class ListUtilsKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi public class MutableSnapshot extends androidx.compose.runtime.snapshots.Snapshot {
    method public androidx.compose.runtime.snapshots.SnapshotApplyResult apply();
    method public void close$lintWithKotlin();
    method public java.util.Set<androidx.compose.runtime.snapshots.StateObject>? getModified$lintWithKotlin();
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getReadObserver$lintWithKotlin();
    method public boolean getReadonly();
    method public androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getWriteObserver$lintWithKotlin();
    method public boolean hasPendingChanges();
    method public void nestedActivated$lintWithKotlin(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void nestedDeactivated$lintWithKotlin(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void notifyObjectsInitialized$lintWithKotlin();
    method public void recordModified$lintWithKotlin(androidx.compose.runtime.snapshots.StateObject state);
    method public void setModified(java.util.Set<androidx.compose.runtime.snapshots.StateObject>? p);
    method public androidx.compose.runtime.snapshots.MutableSnapshot takeNestedMutableSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null, kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver = null);
    method public androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    property public java.util.Set<androidx.compose.runtime.snapshots.StateObject>? modified;
    property public boolean readonly;
    property public androidx.compose.runtime.snapshots.Snapshot root;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public abstract sealed class Snapshot {
    method public void dispose();
    method public final inline <T> T! enter(kotlin.jvm.functions.Function0<? extends T> block);
    method public int getId();
    method public abstract boolean getReadonly();
    method public abstract androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public abstract boolean hasPendingChanges();
    method public void setId$lintWithKotlin(int p);
    method public abstract androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null);
    property public int id;
    property public abstract boolean readonly;
    property public abstract androidx.compose.runtime.snapshots.Snapshot root;
    field public static final androidx.compose.runtime.snapshots.Snapshot.Companion Companion;
  }

  public static final class Snapshot.Companion {
    method public androidx.compose.runtime.snapshots.Snapshot! getCurrent();
    method public inline <T> T! global(kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ExperimentalComposeApi public void notifyObjectsInitialized();
    method public <T> T! observe(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null, kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver = null, kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.InternalComposeApi public int openSnapshotCount();
    method public kotlin.jvm.functions.Function0<kotlin.Unit> registerApplyObserver(kotlin.jvm.functions.Function2<? super java.util.Set<?>,? super androidx.compose.runtime.snapshots.Snapshot,kotlin.Unit> observer);
    method @androidx.compose.runtime.ExperimentalComposeApi public kotlin.jvm.functions.Function0<kotlin.Unit> registerGlobalWriteObserver(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit> observer);
    method @androidx.compose.runtime.ExperimentalComposeApi public void sendApplyNotifications();
    property public final androidx.compose.runtime.snapshots.Snapshot! current;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public final class SnapshotApplyConflictException extends java.lang.Exception {
    ctor public SnapshotApplyConflictException(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
  }

  public abstract sealed class SnapshotApplyResult {
    method public abstract void check();
    method public abstract boolean getSucceeded();
    property public abstract boolean succeeded;
  }

  public static final class SnapshotApplyResult.Failure extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    ctor public SnapshotApplyResult.Failure(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void check();
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
    method public boolean getSucceeded();
    property public boolean succeeded;
  }

  public static final class SnapshotApplyResult.Success extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    method public void check();
    method public boolean getSucceeded();
    property public boolean succeeded;
    field public static final androidx.compose.runtime.snapshots.SnapshotApplyResult.Success INSTANCE;
  }

  public final class SnapshotIdSetKt {
  }

  public final class SnapshotKt {
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state);
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.snapshots.MutableSnapshot takeMutableSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null, kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver = null);
    method public static androidx.compose.runtime.snapshots.Snapshot takeSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver = null);
    method @androidx.compose.runtime.ExperimentalComposeApi public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! withCurrent(T, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! writable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! writable(T, androidx.compose.runtime.snapshots.StateObject state, kotlin.jvm.functions.Function1<? super T,? extends R> block);
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateList<T> implements kotlin.jvm.internal.markers.KMutableList java.util.List<T> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateList();
    method public boolean add(T? element);
    method public void add(int index, T? element);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public void clear();
    method public boolean contains(Object? element);
    method public boolean containsAll(java.util.Collection<?> elements);
    method public T! get(int index);
    method public androidx.compose.runtime.snapshots.SnapshotStateList.StateListStateRecord<T> getFirstStateRecord();
    method public int getSize();
    method public int indexOf(Object? element);
    method public boolean isEmpty();
    method public java.util.Iterator<T> iterator();
    method public int lastIndexOf(Object? element);
    method public java.util.ListIterator<T> listIterator();
    method public java.util.ListIterator<T> listIterator(int index);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public boolean remove(Object? element);
    method public boolean removeAll(java.util.Collection<?> elements);
    method public T! removeAt(int index);
    method public void removeRange(int fromIndex, int toIndex);
    method public boolean retainAll(java.util.Collection<?> elements);
    method public T! set(int index, T? element);
    method public java.util.List<T> subList(int fromIndex, int toIndex);
    property public androidx.compose.runtime.snapshots.SnapshotStateList.StateListStateRecord<T> firstStateRecord;
    property public int size;
  }

  public static final class SnapshotStateList.StateListStateRecord<T> extends androidx.compose.runtime.snapshots.StateRecord {
    method public void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public androidx.compose.runtime.snapshots.StateRecord create();
  }

  public final class SnapshotStateListKt {
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateMap<K, V> implements kotlin.jvm.internal.markers.KMutableMap java.util.Map<K,V> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateMap();
    method public void clear();
    method public boolean containsKey(Object? key);
    method public boolean containsValue(Object? value);
    method public V? get(Object? key);
    method public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method public androidx.compose.runtime.snapshots.SnapshotStateMap.StateMapStateRecord<K,V> getFirstStateRecord();
    method public java.util.Set<K> getKeys();
    method public int getSize();
    method public java.util.Collection<V> getValues();
    method public boolean isEmpty();
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public V? put(K? key, V? value);
    method public void putAll(java.util.Map<? extends K,? extends V> from);
    method public V? remove(Object? key);
    property public java.util.Set<java.util.Map.Entry<K,V>> entries;
    property public androidx.compose.runtime.snapshots.SnapshotStateMap.StateMapStateRecord<K,V> firstStateRecord;
    property public java.util.Set<K> keys;
    property public int size;
    property public java.util.Collection<V> values;
  }

  public static final class SnapshotStateMap.StateMapStateRecord<K, V> extends androidx.compose.runtime.snapshots.StateRecord {
    method public void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public androidx.compose.runtime.snapshots.StateRecord create();
  }

  public final class SnapshotStateMapKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi public final class SnapshotStateObserver {
    ctor public SnapshotStateObserver(kotlin.jvm.functions.Function1<? super kotlin.jvm.functions.Function0<kotlin.Unit>,kotlin.Unit> onChangedExecutor);
    method public void clear(Object target);
    method public void dispose();
    method public void enableStateUpdatesObserving(boolean enabled);
    method public <T> void observeReads(T target, kotlin.jvm.functions.Function1<? super T,kotlin.Unit> onChanged, kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method public void pauseObservingReads(kotlin.jvm.functions.Function0<kotlin.Unit> block);
  }

  @androidx.compose.runtime.ExperimentalComposeApi public interface StateObject {
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public default androidx.compose.runtime.snapshots.StateRecord? mergeRecords(androidx.compose.runtime.snapshots.StateRecord previous, androidx.compose.runtime.snapshots.StateRecord current, androidx.compose.runtime.snapshots.StateRecord applied);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    property public abstract androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public abstract class StateRecord {
    ctor public StateRecord();
    method public abstract void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public abstract androidx.compose.runtime.snapshots.StateRecord create();
  }

}

package androidx.compose.runtime.tooling {

  public final class InspectionTablesKt {
    method public static androidx.compose.runtime.ProvidableAmbient<java.util.Set<androidx.compose.runtime.SlotTable>> getInspectionTables();
  }

}

